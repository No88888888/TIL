# 0824_Queue

## 기본개념

> 뒤에서는 삽입& 앞에서는 삭제만 하는 자료구조
Stack과 가장 큰 차이는 “FIFO”
- Stack → top으로 관리
- Queue → front, rear로 관리
> 

큐의 특성

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
    - 큐의 뒤에서는 삽입만 하고 앞에서는 삭제만 이루어지는 구조
- 선입선출구조(FIFO)

큐의 기본 연산

- 공백 큐 만들기
    - front&rear = -1
- 원소의 삽입 과정 ⇒ rear의 증가(enQueue)
- 원소의 삭제 과정 ⇒ fornt의 증가(deQueue)
- front == rear ⇒ empty
- rear = len(Q) - 1 ⇒ full

```python
def isFull():
	return rear = len(queue) - 1
```

---

### 선형큐와 원형큐의 가장 큰 차이점

- 초기 상태 : front == rear == 0
- 원형큐의 isFull()

```python
def isFull():
	return (rear+1) % len(Cqueue) == front
```

### 선형큐

- 1차원 배열 큐
    - front: 저장된 첫 번째 원소의 인덱스
    - rear: 저장된 마지막 원소의 인덱스
- 상태 표현
    - 초기상태 : front = rear = -1
    - 공백상태 : front == rear
    - 포화상태 : rear == n-1

### 원형큐

- 초기 공백 상태
    - front = rear = 0
- Index의 순환
    - front 와 rear의 위치가 배열이 마지막 인덱스인 n-1를 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
    - 이를 위해 나머지 연산자 mod 사용
- front 변수
    - 공백 상태와 포화 생태 구분 위해 `front가 있는 자리는 사용하지 않고 항상 빈자리`로 둠

### 우선순위 큐

- 특성
    - FIFO 순서가 아니라 우선순위를 가진 순서대로 먼저 나가게 된다

## 큐의 활용

- 버퍼
    - 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
    - 순서대로 입,출력되야하므로 FIFO 방식의 자료구조인 큐가 활용

---

# BFS(너비우선탐색)

- 그래프를 탐색하는 방법 두가지
    - 깊이 우선탐색
    - 너비 우선탐색
        - 인접한 정점들에 대해 탐색한 수 차례로 다시 너비 우선 탐색을 진행하야하므로 선입선출 형태의 자료구조인 큐를 활용함

### 탐색

- 빠짐없이 중복없이: DFS,BFS
- 최단거리: DFS, BFS
- 경로의 수: DFS
- 확산(출발이 여러곳): BFS